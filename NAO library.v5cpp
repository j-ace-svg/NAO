{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\n\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       {author}                                                  */\n/*    Created:      {date}                                                    */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Include the V5 Library\n#include \"vex.h\"\n\n// Included libraries (some redundent because of config block)\n#include <math.h>\n#include <array>\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n/* --------------- Start drive library --------------- */\n\n#pragma region Custom Drive Library\n\n#define INF std::numeric_limits<float>::infinity()\n\nclass Drive {\n  public:\n    motor_group* leftDrive;\n    motor_group* rightDrive;\n    directionType leftDirection = forward;\n    directionType rightDirection = reverse;\n    inertial* inertialSensor;\n    \n    controller* remoteControl;\n\n  Drive(motor_group &_leftDrive, motor_group &_rightDrive, inertial &_inertialSensor, controller &_remoteControl) {\n    leftDrive = &_leftDrive;\n    rightDrive = &_rightDrive;\n    inertialSensor = &_inertialSensor;\n    remoteControl = &_remoteControl;\n  }\n\n  Drive(motor_group &_leftDrive, motor_group &_rightDrive, directionType _leftDirection, directionType _rightDirection, inertial &_inertialSensor, controller &_remoteControl) {\n    leftDrive = &_leftDrive;\n    rightDrive = &_rightDrive;\n    leftDirection = _leftDirection;\n    rightDirection = _rightDirection;\n    inertialSensor = &_inertialSensor;\n    remoteControl = &_remoteControl;\n  }\n\n  void driverControl() {\n    leftDrive->setVelocity(remoteControl->Axis3.position(), percent);\n    if (abs(remoteControl->Axis3.position()) > 3) {\n      leftDrive->spin(leftDirection);\n    }\n    rightDrive->setVelocity(remoteControl->Axis2.position(), percent);\n    if (abs(remoteControl->Axis2.position()) > 3) {\n      rightDrive->spin(rightDirection);\n    }\n  }\n\n};\n\nusing transformMatrix = array<array<float, 2>, 2>;\n\nstruct coordinate {\n  float x;\n  float y;\n\n  coordinate(int x, int y) : x(x), y(y) {\n  }\n\n  coordinate& operator=(const coordinate& a) {\n    x = a.x;\n    y = a.y;\n    return *this;\n  }\n\n  coordinate operator+(const coordinate& a) {\n    return coordinate(a.x + x, a.y + y);\n  }\n\n  bool operator==(const coordinate& a) {\n    return (x == a.x && y == a.y);\n  }\n\n  coordinate& operator*(const transformMatrix& trans) {\n    return coordinate(x * trans[0][0] + y * trans[1][0], x * trans[0][1] + y * trans[1][1]);\n  }\n};\n\nclass Odometry {\n  private:\n    float resetOrientGlobal; // Global orientation at last reset\n    float oldTimestamp;\n    float oldLeftAngle;\n    float oldRightAngle;\n    float oldOrientGlobal;\n    coordinate oldGlobalPosition; // Previous global position vector\n    float timestamp;\n    float leftAngle;\n    float rightAngle;\n    float orientGlobal;\n    coordinate globalPosition;\n    float slippingEpsilon = 0.01;\n\n  public:\n    motor_group leftDrive;\n    motor_group rightDrive;\n    inertial inertialSensor;\n    float distLeft; // Distance from tracking center to left tracking wheel\n    float distRight; // Distance from tracking center to right tracking wheel\n    float distBack; // Distance from tracking center to back tracking wheel\n    float leftWheelRadius;\n    float rightWheelRadius;\n\n    void initSensorValues() {\n      timestamp = Brain.Timer.time(seconds);\n      leftAngle = leftDrive.position(turns) * 2 * M_PI;\n      rightAngle = rightDrive.position(turns) * 2 * M_PI;\n      orientGlobal = inertialSensor.rotation(turns) * 2 * M_PI;\n      oldTimestamp = timestamp;\n      oldLeftAngle = leftAngle;\n      oldRightAngle = rightAngle;\n      oldOrientGlobal = orientGlobal;\n      resetOrientGlobal = orientGlobal;\n    }\n\n    void pollSensorValues() {\n      oldTimestamp = timestamp;\n      oldLeftAngle = leftAngle;\n      oldRightAngle = rightAngle;\n      oldOrientGlobal = orientGlobal;\n      timestamp = Brain.Timer.time(seconds);\n      leftAngle = leftDrive.position(turns) * 2 * M_PI;\n      rightAngle = rightDrive.position(turns) * 2 * M_PI;\n      orientGlobal = inertialSensor.rotation(turns) * 2 * M_PI;\n\n      // Calculate odometry\n      oldGlobalPosition = globalPosition;\n      globalPosition += getGlobalPositionChange();\n    }\n\n    // Getter methods\n\n    float getLeftAngle() {\n      return leftAngle;\n    }\n\n    float getRightAngle() {\n      return rightAngle;\n    }\n\n    float getOrientation() {\n      return orientGlobal - resetOrientGlobal;\n    }\n\n    float getOldOrientation() {\n      return oldOrientGlobal;\n    }\n\n    coordinate getOldGlobalPosition() {\n      return oldGlobalPosition;\n    }\n\n    coordinate getGlobalPosition() {\n      return globalPosition;\n    }\n\n    float getDeltaTime() {\n      return timestamp - oldTimestamp;\n    }\n\n    float getDeltaLeftAngle() {\n      return leftAngle - oldLeftAngle;\n    }\n\n    float getDeltaLeftDistance() {\n      return getDeltaLeftAngle() * leftWheelRadius;\n    }\n\n    float getDeltaRightAngle() {\n      return rightAngle - oldRightAngle;\n    }\n\n    float getDeltaRightDistance() {\n      return getDeltaRightAngle() * rightWheelRadius;\n    }\n\n    float getDeltaOrientation() {\n      return orientGlobal - oldOrientGlobal;\n    }\n\n    coordinate getDeltaGlobalPosition() {\n      return globalPosition - oldGlobalPosition;\n    }\n\n    float getPredictedDeltaOrientation() {\n      float leftRightAngleDifference = getDeltaLeftAngle() - getDeltaRightAngle();\n      float drivetrainWidth = distLeft + distRight;\n      return leftRightAngleDifference / drivetrainWidth;\n    }\n\n    float getPathArcRadius() {\n      if (getDeltaOrientation() == 0) return INF;\n      if (getDeltaLeftAngle() == 0 && getDeltaRightAngle() == 0) return INF;\n      float leftRadius = getDeltaLeftDistance() / getDeltaOrientation() - distLeft;\n      float leftVelocity = leftRadius * getDeltaOrientation() / getDeltaTime();\n      float leftAcceleration = pow(leftVelocity, 2) / leftRadius;\n      float rightRadius = getDeltaRightDistance() / getDeltaOrientation() + distRight;\n      float rightVelocity = rightRadius * getDeltaOrientation() / getDeltaTime();\n      float rightAcceleration = pow(rightVelocity, 2) / rightRadius;\n      \n      float inertialAcceleration = inertialSensor.acceleration(yaxis);\n\n      float minSideRadiusAcceleration = leftAcceleration;\n      float minSideRadiusVelocity = leftVelocity;\n      float minSideRadius = leftRadius;\n      float minSideDeltaAngle = getDeltaLeftDistance();\n      float minSideDist = distLeft;\n\n      if (leftRadius > rightRadius) { // One side slipped more than the other\n        minSideRadiusAcceleration = rightAcceleration;\n        minSideRadiusVelocity = rightVelocity;\n        minSideRadius = rightRadius;\n        minSideDeltaAngle = getDeltaRightDistance();\n        minSideDist = distRight;\n      }\n      if (fabs(minSideRadiusAcceleration - inertialAcceleration) > slippingEpsilon) { // Slippage on both sides\n        minSideRadiusAcceleration = inertialAcceleration;\n        minSideRadiusVelocity = sqrt(minSideRadiusAcceleration * minSideRadius);\n        minSideRadius = minSideRadiusVelocity * getDeltaTime() / getDeltaOrientation();\n      }\n\n      return minSideRadius;\n    }\n\n    coordinate getGlobalPositionChange() {\n      coordinate localChange = {0, 2 * sin(getDeltaOrientation() / 2) * getPathArcRadius()};\n\n      float localRotationOffset = getOldOrientation() + getDeltaOrientation() / 2;\n\n      transformMatrix rotationMatrix = {{cos(-localRotationOffset), -sin(-localRotationOffset)}, {sin(-localRotationOffset), cos(-localRotationOffset)}};\n\n      coordinate globalChange = localChange * rotationMatrix;\n      return globalChange;\n    }\n};\n\n#pragma endregion Custom Drive Library\n\n/* --------------- Start robot configuration --------------- */\n\nmotor LeftDriveMotorFront = motor(PORT1, ratio6_1, false);\nmotor LeftDriveMotorMiddle = motor(PORT11, ratio6_1, false);\nmotor LeftDriveMotorBack = motor(PORT12, ratio6_1, false);\nmotor_group LeftDrive = motor_group(LeftDriveMotorFront, LeftDriveMotorMiddle, LeftDriveMotorBack);\n\nmotor RightDriveMotorFront = motor(PORT10, ratio6_1, true);\nmotor RightDriveMotorMiddle = motor(PORT19, ratio6_1, true);\nmotor RightDriveMotorBack = motor(PORT20, ratio6_1, true);\nmotor_group RightDrive = motor_group(RightDriveMotorFront, RightDriveMotorMiddle, RightDriveMotorBack);\n\ninertial InertialSensor = inertial(PORT5);\n\ncontroller RemoteControl = controller(primary);\n\n/* --------------- Start main program --------------- */\n\n\n\nint main() {\n  Drive * robotDrivetrain = new Drive(LeftDrive, RightDrive, forward, forward, InertialSensor, RemoteControl);\n\n  while (true) {\n    robotDrivetrain->driverControl();\n\n    wait(10, msec);\n  }\n}\n","textLanguage":"cpp","robotConfig":[],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.3","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}