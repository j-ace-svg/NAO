{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\n\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       {author}                                                  */\n/*    Created:      {date}                                                    */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Include the V5 Library\n#include \"vex.h\"\n\n// Included libraries (some redundent because of config block)\n#include <math.h>\n#include <array>\n#include <utility>\nusing std::array;\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n/* --------------- Start drive library --------------- */\n\n#pragma region Custom Drive Library\n\n#define INF std::numeric_limits<float>::infinity()\n#define DT 10\n\nusing transformMatrix = array<array<float, 2>, 2>;\n\nstruct coordinate {\n  float x;\n  float y;\n\n  coordinate(float x, float y) : x(x), y(y) {\n  }\n\n  coordinate& operator=(const coordinate& a) {\n    x = a.x;\n    y = a.y;\n    return *this;\n  }\n\n  coordinate operator+(const coordinate& a) {\n    return coordinate(a.x + x, a.y + y);\n  }\n\n  coordinate operator-(const coordinate& a) {\n    return coordinate(x - a.x, y - a.y);\n  }\n\n  bool operator==(const coordinate& a) {\n    return (x == a.x && y == a.y);\n  }\n\n  coordinate operator*(const transformMatrix& trans) {\n    return coordinate(x * trans[0][0] + y * trans[1][0], x * trans[0][1] + y * trans[1][1]);\n  }\n};\n\nclass Odometry {\n  private:\n    float resetOrientGlobal; // Global orientation at last reset\n    //float orientGlobalDrift;\n    float oldTimestamp;\n    float oldLeftAngle;\n    float oldRightAngle;\n    float oldOrientGlobal;\n    coordinate oldGlobalPosition = {0, 0}; // Previous global position vector\n    float timestamp;\n    float leftAngle;\n    float rightAngle;\n    float orientGlobal;\n    coordinate globalPosition = {0, 0};\n    float slippingEpsilon = 0.01;\n\n  public:\n    motor_group* leftDrive;\n    motor_group* rightDrive;\n    inertial* inertialSensor;\n    float orientGlobalDrift;\n    float inertialDriftEpsilon; // Minimum threshold used to determine whether or not turning is drift\n    float distLeft; // Distance from tracking center to left tracking wheel\n    float distRight; // Distance from tracking center to right tracking wheel\n    float distBack; // Distance from tracking center to back tracking wheel\n    float leftWheelRadius;\n    float rightWheelRadius;\n\n    Odometry(motor_group &_leftDrive, motor_group &_rightDrive, inertial &_inertialSensor, float _inertialDriftEpsilon, float _distLeft, float _distRight, float _distBack, float _leftWheelRadius, float _rightWheelRadius) {\n      leftDrive = &_leftDrive;\n      rightDrive = &_rightDrive;\n      inertialSensor = &_inertialSensor;\n      inertialDriftEpsilon = _inertialDriftEpsilon;\n      distLeft = _distLeft;\n      distRight = _distRight;\n      leftWheelRadius = _leftWheelRadius;\n      rightWheelRadius = _rightWheelRadius;\n    }\n\n    void initSensorValues() {\n      timestamp = Brain.Timer.time(seconds);\n      leftAngle = leftDrive->position(turns) * 2 * M_PI;\n      rightAngle = rightDrive->position(turns) * 2 * M_PI;\n      orientGlobal = inertialSensor->rotation(turns) * 2 * M_PI;\n      orientGlobalDrift = 0;\n      globalPosition = {0, 0};\n      oldTimestamp = timestamp;\n      oldLeftAngle = leftAngle;\n      oldRightAngle = rightAngle;\n      oldOrientGlobal = orientGlobal;\n      resetOrientGlobal = orientGlobal;\n      oldGlobalPosition = globalPosition;\n    }\n\n    void pollSensorValues() {\n      oldTimestamp = timestamp;\n      oldLeftAngle = leftAngle;\n      oldRightAngle = rightAngle;\n      oldOrientGlobal = orientGlobal;\n      timestamp = Brain.Timer.time(seconds);\n      leftAngle = leftDrive->position(turns) * 2 * M_PI;\n      rightAngle = rightDrive->position(turns) * 2 * M_PI;\n      orientGlobal = inertialSensor->rotation(turns) * 2 * M_PI;\n\n      if (fabs(orientGlobal - oldOrientGlobal) < inertialDriftEpsilon) {\n        orientGlobalDrift += orientGlobal - oldOrientGlobal;\n      }\n\n      // Calculate odometry\n      //oldGlobalPosition = globalPosition;\n      //globalPosition = globalPosition + getGlobalPositionChange();\n    }\n\n    // Setter methods\n\n    void resetOrientation() {\n      resetOrientGlobal = orientGlobal;\n    }\n\n    void resetOrientation(float newOrientation) {\n      resetOrientGlobal = orientGlobal - newOrientation;\n    }\n\n    // Getter methods\n\n    float getLeftAngle() {\n      return leftAngle;\n    }\n\n    float getLeftDistance() {\n      return leftAngle * leftWheelRadius;\n    }\n\n    float getRightAngle() {\n      return rightAngle;\n    }\n\n    float getRightDistance() {\n      return rightAngle * rightWheelRadius;\n    }\n\n    float getOrientation() {\n      return orientGlobal - resetOrientGlobal - orientGlobalDrift;\n    }\n\n    float getOldOrientation() {\n      return oldOrientGlobal;\n    }\n\n    coordinate getOldGlobalPosition() {\n      return oldGlobalPosition;\n    }\n\n    coordinate getGlobalPosition() {\n      return globalPosition;\n    }\n\n    float getDeltaTime() {\n      return timestamp - oldTimestamp;\n    }\n\n    float getDeltaLeftAngle() {\n      return leftAngle - oldLeftAngle;\n    }\n\n    float getDeltaLeftDistance() {\n      return getDeltaLeftAngle() * leftWheelRadius;\n    }\n\n    float getDeltaRightAngle() {\n      return rightAngle - oldRightAngle;\n    }\n\n    float getDeltaRightDistance() {\n      return getDeltaRightAngle() * rightWheelRadius;\n    }\n\n    float getDeltaOrientation() {\n      return orientGlobal - oldOrientGlobal;\n    }\n\n    coordinate getDeltaGlobalPosition() {\n      return globalPosition - oldGlobalPosition;\n    }\n\n    float getPredictedDeltaOrientation() {\n      float leftRightAngleDifference = getDeltaLeftAngle() - getDeltaRightAngle();\n      float drivetrainWidth = distLeft + distRight;\n      return leftRightAngleDifference / drivetrainWidth;\n    }\n\n    float getPathArcRadius() {\n      if (getDeltaOrientation() == 0) return INF;\n      if (getDeltaLeftAngle() == 0 && getDeltaRightAngle() == 0) return INF;\n      float leftRadius = getDeltaLeftDistance() / getDeltaOrientation() - distLeft;\n      float leftVelocity = leftRadius * getDeltaOrientation() / getDeltaTime();\n      float leftAcceleration = pow(leftVelocity, 2) / leftRadius;\n      float rightRadius = getDeltaRightDistance() / getDeltaOrientation() + distRight;\n      float rightVelocity = rightRadius * getDeltaOrientation() / getDeltaTime();\n      float rightAcceleration = pow(rightVelocity, 2) / rightRadius;\n      \n      float inertialAcceleration = inertialSensor->acceleration(yaxis);\n\n      float minSideRadiusAcceleration = leftAcceleration;\n      float minSideRadiusVelocity = leftVelocity;\n      float minSideRadius = leftRadius;\n      float minSideDeltaAngle = getDeltaLeftDistance();\n      float minSideDist = distLeft;\n\n      if (leftRadius > rightRadius) { // One side slipped more than the other\n        minSideRadiusAcceleration = rightAcceleration;\n        minSideRadiusVelocity = rightVelocity;\n        minSideRadius = rightRadius;\n        minSideDeltaAngle = getDeltaRightDistance();\n        minSideDist = distRight;\n      }\n      if (fabs(minSideRadiusAcceleration - inertialAcceleration) > slippingEpsilon) { // Slippage on both sides\n        minSideRadiusAcceleration = inertialAcceleration;\n        minSideRadiusVelocity = sqrt(minSideRadiusAcceleration * minSideRadius);\n        minSideRadius = minSideRadiusVelocity * getDeltaTime() / getDeltaOrientation();\n      }\n\n      return minSideRadius;\n    }\n\n    coordinate getGlobalPositionChange() {\n      coordinate localChange = {0, 2 * sinf(getDeltaOrientation() / 2) * getPathArcRadius()};\n\n      float localRotationOffset = getOldOrientation() + getDeltaOrientation() / 2;\n\n      // The extra pair of curly braces around the initializer in the line below is actually necessary (because c funkiness)\n      transformMatrix rotationMatrix = {{{cosf(-localRotationOffset), -sinf(-localRotationOffset)}, {sinf(-localRotationOffset), cosf(-localRotationOffset)}}};\n\n      coordinate globalChange = localChange * rotationMatrix;\n      if (getPathArcRadius() == INF) {\n        float deltaLeftDist = getDeltaLeftDistance();\n        float deltaRightDist = getDeltaRightDistance();\n        if ((deltaLeftDist < 0 && deltaRightDist > 0) || (deltaLeftDist > 0 && deltaRightDist < 0)) { // Forwards and Backwards (no movement)\n          globalChange = {0, 0};\n        } else if (deltaLeftDist == 0 || deltaRightDist == 0) { // No movement\n          globalChange = {0, 0};\n        } else if (deltaLeftDist > 0) { // Forwards\n          if (deltaLeftDist > deltaRightDist) {\n            globalChange = {0, deltaRightDist};\n          } else {\n            globalChange = {0, deltaLeftDist};\n          }\n        } else { // Backwards\n          if (deltaLeftDist > deltaRightDist) {\n            globalChange = {0, deltaLeftDist};\n          } else {\n            globalChange = {0, deltaRightDist};\n          }\n        }\n      }\n      return globalChange;\n    }\n};\n\nclass PID {\n  //private:\n  public:\n    float kp;\n    float ki;\n    float kd;\n    float integralRange;\n    float previousError;\n    float accumulatedError;\n    float timeRunning;\n    float timeout;\n    float settleThreshold;\n    float settleTime;\n    float timeSettled;\n\n  //public:\n\n    PID(float startError, float _kp, float _ki, float _kd, float _integralRange, float _settleThreshold, float _settleTime) {\n      kp = _kp;\n      ki = _ki;\n      kd = _kd;\n      integralRange = _integralRange;\n      settleThreshold = _settleThreshold;\n      settleTime = _settleTime;\n      accumulatedError = 0;\n      previousError = startError;\n      timeRunning = 0;\n      timeSettled = 0;\n    }\n\n    bool isSettled() {\n      if ((timeRunning > timeout && timeout != 0) || timeSettled > settleTime) return true;\n      return false;\n    }\n\n    float calculateNextStep(float error) {\n      // Integral\n      accumulatedError = accumulatedError + error;\n      if (fabs(error) > integralRange) accumulatedError = 0; // Error outside of range for accumulating integral\n      if (error == 0 || (error > 0 &&  previousError < 0) || (error < 0 && previousError > 0)) accumulatedError = 0; // Error crossed 0\n\n      // Derivative\n      float deltaError = error - previousError;\n      previousError = error;\n\n      // Output\n      float outputPower = kp * error + ki * accumulatedError + kd * deltaError;\n      if (fabs(error) < settleThreshold) timeSettled += DT;\n      timeRunning += DT;\n      return outputPower;\n    }\n};\n\nstruct odomParameters {\n  float kp;\n  float ki;\n  float kd;\n  float integralRange;\n  float settleThreshold;\n  float settleTime;\n  float maxVelocity;\n\n  odomParameters(float kp, float ki, float kd, float integralRange, float settleThreshold, float settleTime, float maxVelocity) : kp(kp), ki(ki), kd(kd), integralRange(integralRange), settleThreshold(settleThreshold), settleTime(settleTime), maxVelocity(maxVelocity) {\n  }\n\n};\n\nclass Drive {\n  public:\n    motor_group* leftDrive;\n    motor_group* rightDrive;\n    directionType leftDirection = forward;\n    directionType rightDirection = reverse;\n    inertial* inertialSensor;\n    \n    controller* remoteControl;\n\n    Odometry* odom;\n    odomParameters straightParameters = {0, 0, 0, 0, 0, 0, 0};\n    odomParameters turnParameters = {0, 0, 0, 0, 0, 0, 0};\n    odomParameters arcParameters = {0, 0, 0, 0, 0, 0, 0};\n    odomParameters headingParameters = {0, 0, 0, 0, 0, 0, 0};\n\n  Drive(motor_group &_leftDrive, motor_group &_rightDrive, inertial &_inertialSensor, controller &_remoteControl) {\n    leftDrive = &_leftDrive;\n    rightDrive = &_rightDrive;\n    inertialSensor = &_inertialSensor;\n    remoteControl = &_remoteControl;\n  }\n\n  Drive(motor_group &_leftDrive, motor_group &_rightDrive, directionType _leftDirection, directionType _rightDirection, inertial &_inertialSensor, controller &_remoteControl) {\n    leftDrive = &_leftDrive;\n    rightDrive = &_rightDrive;\n    leftDirection = _leftDirection;\n    rightDirection = _rightDirection;\n    inertialSensor = &_inertialSensor;\n    remoteControl = &_remoteControl;\n  }\n\n  void initOdom(float inertialDriftEpsilon, float distLeft, float distRight, float distBack, float leftWheelRadius, float rightWheelRadius, odomParameters _straightParameters, odomParameters _turnParameters, odomParameters _arcParameters, odomParameters _headingParameters) {\n    odom = new Odometry(*leftDrive, *rightDrive, *inertialSensor, inertialDriftEpsilon, distLeft, distRight, distBack, leftWheelRadius, rightWheelRadius);\n    odom->initSensorValues();\n    straightParameters = _straightParameters;\n    turnParameters = _turnParameters;\n    arcParameters = _arcParameters;\n    headingParameters = _headingParameters;\n  }\n\n  void driverControl() {\n    leftDrive->setVelocity(remoteControl->Axis3.position(), percent);\n    if (abs(remoteControl->Axis3.position()) > 3) {\n      leftDrive->spin(leftDirection);\n    }\n    rightDrive->setVelocity(remoteControl->Axis2.position(), percent);\n    if (abs(remoteControl->Axis2.position()) > 3) {\n      rightDrive->spin(rightDirection);\n    }\n  }\n\n  // General drive functions\n  void driveVelocity(float leftMotorPower, float rightMotorPower) {\n    leftDrive->setVelocity(leftMotorPower, percent);\n    if (leftMotorPower == 0) {\n      leftDrive->stop(hold);\n    } else {\n      leftDrive->spin(leftDirection);\n    }\n\n    rightDrive->setVelocity(rightMotorPower, percent);\n    if (rightMotorPower == 0) {\n      rightDrive->stop(hold);\n    } else {\n      rightDrive->spin(rightDirection);\n    }\n  }\n\n  void driveVelocity(float motorPower) {\n    driveVelocity(motorPower, motorPower);\n  }\n\n  float clampStraightVelocity(float motorVelocity) {\n    if (motorVelocity > straightParameters.maxVelocity) {\n      return straightParameters.maxVelocity;\n    } else if (motorVelocity < -straightParameters.maxVelocity) {\n      return -straightParameters.maxVelocity;\n    } else {\n      return motorVelocity;\n    }\n  }\n\n  float clampTurnVelocity(float motorVelocity) {\n    if (motorVelocity > turnParameters.maxVelocity) {\n      return turnParameters.maxVelocity;\n    } else if (motorVelocity < -turnParameters.maxVelocity) {\n      return -turnParameters.maxVelocity;\n    } else {\n      return motorVelocity;\n    }\n  }\n\n  float clampArcVelocity(float motorVelocity) {\n    if (motorVelocity > turnParameters.maxVelocity) {\n      return turnParameters.maxVelocity;\n    } else if (motorVelocity < -turnParameters.maxVelocity) {\n      return -turnParameters.maxVelocity;\n    } else {\n      return motorVelocity;\n    }\n  }\n\n  float clampHeadingVelocity(float motorVelocity) {\n    if (motorVelocity > headingParameters.maxVelocity) {\n      return headingParameters.maxVelocity;\n    } else if (motorVelocity < -headingParameters.maxVelocity) {\n      return -headingParameters.maxVelocity;\n    } else {\n      return motorVelocity;\n    }\n  }\n\n  float reduceAngleNegPiToPi(float headingAngle) { // Inspired by a pretty convenient utility function by Jackson Area Robotics\n    // Not using modulo because negative inputs are implementation dependent...\n    while (headingAngle > M_PI || headingAngle <= -M_PI) {\n      if (headingAngle > M_PI) {\n        headingAngle -= 2 * M_PI;\n      } else {\n        headingAngle += 2 * M_PI;\n      }\n    }\n    return headingAngle;\n  }\n\n  float degreesToRadians(float angleDegrees) {\n    return angleDegrees * M_PI / 180;\n  }\n\n  // Drivetrain autonomous functions\n  void odometryStep() {\n    wait(DT, msec);\n    odom->pollSensorValues();\n  }\n  \n  void driveDistance(float dist) {\n    float driveSetPoint = dist + (odom->getLeftDistance() + odom->getRightDistance()) / 2;\n    PID* drivePID = new PID(dist, straightParameters.kp, straightParameters.ki, straightParameters.kd, straightParameters.integralRange, straightParameters.settleThreshold, straightParameters.settleTime);\n    float headingSetPoint = odom->getOrientation();\n    PID* headingPID = new PID(0, headingParameters.kp, headingParameters.ki, headingParameters.kd, headingParameters.integralRange, headingParameters.settleThreshold, headingParameters.settleTime);\n    while (!drivePID->isSettled()) {\n      float distanceError = driveSetPoint - (odom->getLeftDistance() + odom->getRightDistance()) / 2;\n      //remoteControl->Screen.clearScreen();\n      //remoteControl->Screen.setCursor(1,1);\n      //remoteControl->Screen.print(\"Time settled: %f\", turnPID->timeSettled);\n      //remoteControl->Screen.print(\"Error: %f\", distanceError);\n      float driveMotorVelocity = drivePID->calculateNextStep(distanceError);\n      \n      driveMotorVelocity = clampStraightVelocity(driveMotorVelocity);\n\n      float headingError = reduceAngleNegPiToPi(headingSetPoint - odom->getOrientation());\n      float headingMotorVelocity = headingPID->calculateNextStep(headingError);\n\n      Brain.Screen.clearLine(2);\n      Brain.Screen.setCursor(2, 1);\n      Brain.Screen.print(\"Motor velocity: %f\", driveMotorVelocity);\n\n      headingMotorVelocity = clampHeadingVelocity(headingMotorVelocity);\n      \n      driveVelocity(driveMotorVelocity + headingMotorVelocity, driveMotorVelocity - headingMotorVelocity);\n\n      odometryStep();\n    }\n    driveVelocity(0);\n  }\n\n  // Drivetrain autonomous functions\n  void turnToAngle(float targetAngle) {\n    float turnSetPoint = targetAngle;\n    PID* turnPID = new PID(turnSetPoint - odom->getOrientation(), turnParameters.kp, turnParameters.ki, turnParameters.kd, turnParameters.integralRange, turnParameters.settleThreshold, turnParameters.settleTime);\n    while (!turnPID->isSettled()) {\n      float turnError = reduceAngleNegPiToPi(turnSetPoint - odom->getOrientation());\n      //remoteControl->Screen.clearScreen();\n      //remoteControl->Screen.setCursor(1,1);\n      //remoteControl->Screen.print(\"Time settled: %f\", turnPID->timeSettled);\n      //remoteControl->Screen.print(\"Error: %f\", turnError);\n      //remoteControl->Screen.newLine();\n      //remoteControl->Screen.print(\"Orientation: %f\", odom->getOrientation());\n      float turnMotorVelocity = turnPID->calculateNextStep(turnError);\n\n      turnMotorVelocity = clampTurnVelocity(turnMotorVelocity);\n      \n      driveVelocity(turnMotorVelocity, -turnMotorVelocity);\n\n      odometryStep();\n    }\n    driveVelocity(0);\n  }\n\n  void turnToAngleDegrees(float targetAngleDegrees) {\n    turnToAngle(degreesToRadians(targetAngleDegrees));\n  }\n  \n  void driveLazyArcDistance(float ang, float dist) {\n    float driveSetPoint = dist + (odom->getLeftDistance() + odom->getRightDistance()) / 2;\n    PID* drivePID = new PID(dist, straightParameters.kp, straightParameters.ki, straightParameters.kd, straightParameters.integralRange, straightParameters.settleThreshold, straightParameters.settleTime);\n    float turnSetPoint = odom->getOrientation() + ang;\n    PID* turnPID = new PID(0, turnParameters.kp, turnParameters.ki, turnParameters.kd, turnParameters.integralRange, turnParameters.settleThreshold, turnParameters.settleTime);\n    while (!turnPID->isSettled()) {\n      float distanceError = driveSetPoint - (odom->getLeftDistance() + odom->getRightDistance()) / 2;\n      //remoteControl->Screen.clearScreen();\n      //remoteControl->Screen.setCursor(1,1);\n      //remoteControl->Screen.print(\"Time settled: %f\", turnPID->timeSettled);\n      //remoteControl->Screen.print(\"Error: %f\", distanceError);\n      float driveMotorVelocity = drivePID->calculateNextStep(distanceError);\n      \n      driveMotorVelocity = clampStraightVelocity(driveMotorVelocity);\n\n      float turnError = reduceAngleNegPiToPi(turnSetPoint - odom->getOrientation());\n      float turnMotorVelocity = turnPID->calculateNextStep(turnError);\n\n      Brain.Screen.clearLine(2);\n      Brain.Screen.setCursor(2, 1);\n      Brain.Screen.print(\"Motor velocity: %f\", driveMotorVelocity);\n\n      turnMotorVelocity = clampTurnVelocity(turnMotorVelocity);\n      \n      driveVelocity(driveMotorVelocity + turnMotorVelocity, driveMotorVelocity - turnMotorVelocity);\n\n      odometryStep();\n    }\n    driveVelocity(0);\n  }\n  \n  void driveLazyArcRadius(float ang, float radius) {\n    // s = r * theta\n    float dist = radius * ang;\n\n    driveLazyArcDistance(ang, dist);\n  }\n\n  void driveArcRadius(float ang, float radius) {\n    float arcDistLeft = (radius + odom->distLeft) * ang;\n    float arcDistRight = (radius - odom->distRight) * ang;\n\n    float speedProportionLeft = 1;\n    float speedProportionRight = 1;\n    float angSign = (ang > 0) - (ang < 0);\n    if (fabs(arcDistLeft) > fabs(arcDistRight)) {\n      speedProportionLeft = arcDistLeft / fabs(arcDistLeft) * angSign;\n      speedProportionRight = arcDistRight / fabs(arcDistLeft) * angSign;\n    } else {\n      speedProportionLeft = arcDistLeft / fabs(arcDistRight) * angSign;\n      speedProportionRight = arcDistRight / fabs(arcDistRight) * angSign;\n    }\n\n    float turnRate = fabs(speedProportionLeft - speedProportionRight) / 2;\n\n    float arcSetPoint = odom->getOrientation() + ang;\n    PID* arcPID = new PID(0, arcParameters.kp, arcParameters.ki, arcParameters.kd, arcParameters.integralRange, arcParameters.settleThreshold, arcParameters.settleTime);\n    while (!arcPID->isSettled()) {\n      float arcError = reduceAngleNegPiToPi(arcSetPoint - odom->getOrientation());\n      float arcMotorVelocity = arcPID->calculateNextStep(arcError) / turnRate;\n\n      arcMotorVelocity = clampArcVelocity(arcMotorVelocity);\n      \n      driveVelocity(speedProportionLeft * arcMotorVelocity, speedProportionRight * arcMotorVelocity);\n\n      odometryStep();\n    }\n    driveVelocity(0);\n  }\n};\n\n#pragma endregion Custom Drive Library\n\n/* --------------- Start robot configuration --------------- */\n\n// Drivetrain\nmotor LeftDriveMotorFront = motor(PORT4, ratio6_1, true);\nmotor LeftDriveMotorMiddle = motor(PORT3, ratio6_1, true);\nmotor LeftDriveMotorBack = motor(PORT2, ratio6_1, true);\nmotor_group LeftDrive = motor_group(LeftDriveMotorFront, LeftDriveMotorMiddle, LeftDriveMotorBack);\n\nmotor RightDriveMotorFront = motor(PORT7, ratio6_1, false);\nmotor RightDriveMotorMiddle = motor(PORT8, ratio6_1, false);\nmotor RightDriveMotorBack = motor(PORT9, ratio6_1, false);\nmotor_group RightDrive = motor_group(RightDriveMotorFront, RightDriveMotorMiddle, RightDriveMotorBack);\n\ninertial InertialSensor = inertial(PORT5);\n\n\n// Intake\nmotor IntakeRollerMotor = motor(PORT6, ratio36_1, false);\nmotor IntakeBeltMotor = motor(PORT10, ratio36_1, true);\n\n// Arm\nmotor ArmMotor = motor(PORT19, ratio18_1, false);\nrotation ArmRotationSensor = rotation(PORT1, false);\n\n// Doinker\ndigital_out DoinkerPneumatic = digital_out(Brain.ThreeWirePort.F);\n\n// Descorer\ndigital_out DescorerPneumatic = digital_out(Brain.ThreeWirePort.A);\n\n// MoGo Mech\ndigital_out LeftMoGoPneumatic = digital_out(Brain.ThreeWirePort.G);\ndigital_out RightMoGoPneumatic = digital_out(Brain.ThreeWirePort.H);\ncontroller RemoteControl = controller(primary);\n\n\n// Odometry\nfloat InertialDriftEpsilon = 0.000025;\nfloat DistLeft = 7.5;\nfloat DistRight = 7.5;\nfloat DistBack = 0;\nfloat LeftWheelRadius = 1.625;\nfloat RightWheelRadius = 1.625;\n/* kp, ki, kd, integralRange, settleThreshold, settleTime, maxVelocity */\nodomParameters StraightParameters = {5, 0, 0, 0, 0.25, 0.25, 80};\nodomParameters TurnParameters = {26.2, 0.009, 40, M_PI / 2, 0.035, 0.2, 50}; // kU = 34, pU = 1.398\nodomParameters ArcParameters = {26.2, 0.009, 40, M_PI / 2, 0.035, 0.2, 50}; // Starting with copy/paste of TurnParameters\nodomParameters HeadingParameters = {40, 0.020, 40, M_PI / 2, 0.035, 0.2, 0};\n\n/* --------------- Start autons --------------- */\n\nvoid odomDebugAuton(Drive* robotDrivetrain, motor &intakeBeltMotor, motor &armMotor, rotation &armRotationSensor, digital_out &doinkerPneumatic, digital_out &descorerPneumatic, motor &IntakeRollerMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  while (true) {\n    Brain.Screen.clearScreen();\n    Brain.Screen.setCursor(1, 1);\n    coordinate globalPosition = robotDrivetrain->odom->getGlobalPosition();\n    float xCoordinate = globalPosition.x;\n    float yCoordinate = globalPosition.y;\n    float leftRotation = robotDrivetrain->odom->getDeltaLeftAngle();\n    float rightRotation = robotDrivetrain->odom->getDeltaRightAngle();\n    float robotOrientation = robotDrivetrain->odom->getOrientation();\n    float arcRadius = robotDrivetrain->odom->getPathArcRadius();\n    Brain.Screen.print(\"X coordinate: %f\", xCoordinate);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Y coordinate: %f\", yCoordinate);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Left rotation: %f\", leftRotation);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Right rotation: %f\", rightRotation);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Orientation: %f\", robotOrientation);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Arc Radius: %f\", arcRadius);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"X: %f\", globalPosition.x);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Y: %f\", globalPosition.y);\n\n\n\n    robotDrivetrain->odometryStep();\n  }\n}\n\nvoid redLowAlly(Drive* robotDrivetrain, motor &intakeBeltMotor, motor &armMotor, rotation &armRotationSensor, digital_out &doinkerPneumatic, digital_out &descorerPneumatic, motor &IntakeRollerMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  robotDrivetrain->straightParameters.maxVelocity = 35;\n  robotDrivetrain->turnParameters.maxVelocity = 40;\n  robotDrivetrain->driveDistance(-17.3);\n  robotDrivetrain->turnToAngle(-M_PI/2);\n  robotDrivetrain->driveDistance(-1.6);\n  LeftMoGoPneumatic.set(true);\n  RightMoGoPneumatic.set(true);\n  IntakeRollerMotor.setVelocity(100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  IntakeRollerMotor.spin(forward);\n  wait(1000, msec);\n  intakeBeltMotor.stop();\n  IntakeRollerMotor.stop();\n  LeftMoGoPneumatic.set(false);\n  RightMoGoPneumatic.set(false);\n  robotDrivetrain->driveDistance(3);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->turnParameters.maxVelocity = 80;\n  robotDrivetrain->turnToAngle(M_PI*.665);\n  robotDrivetrain->driveDistance(-40);\n  robotDrivetrain->straightParameters.maxVelocity = 35;\n  robotDrivetrain->driveDistance(-9);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  LeftMoGoPneumatic.set(true);\n  RightMoGoPneumatic.set(true);\n  wait(500, msec);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->driveDistance(6.5);\n  robotDrivetrain->turnToAngle(-M_PI*.08);\n  intakeBeltMotor.spin(forward);\n  IntakeRollerMotor.spin(forward);\n  robotDrivetrain->driveDistance(37);\n  wait(1500, msec);\n  robotDrivetrain->turnParameters.maxVelocity = 50;\n  robotDrivetrain->turnToAngle(M_PI*1.075);\n}\n\nvoid blueLowAlly(Drive* robotDrivetrain, motor &intakeBeltMotor, motor &armMotor, rotation &armRotationSensor, digital_out &doinkerPneumatic, digital_out &descorerPneumatic, motor &IntakeRollerMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  robotDrivetrain->straightParameters.maxVelocity = 35;\n  robotDrivetrain->turnParameters.maxVelocity = 40;\n  robotDrivetrain->driveDistance(-17.3);\n  robotDrivetrain->turnToAngle(M_PI/2);\n  robotDrivetrain->driveDistance(-1.85);\n  LeftMoGoPneumatic.set(true);\n  RightMoGoPneumatic.set(true);\n  IntakeRollerMotor.setVelocity(100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  IntakeRollerMotor.spin(forward);\n  wait(1000, msec);\n  intakeBeltMotor.stop();\n  IntakeRollerMotor.stop();\n  LeftMoGoPneumatic.set(false);\n  RightMoGoPneumatic.set(false);\n  robotDrivetrain->driveDistance(3.25);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->turnParameters.maxVelocity = 80;\n  robotDrivetrain->turnToAngle(-M_PI*.68);\n  robotDrivetrain->driveDistance(-37);\n  robotDrivetrain->straightParameters.maxVelocity = 35;\n  robotDrivetrain->driveDistance(-12);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  LeftMoGoPneumatic.set(true);\n  RightMoGoPneumatic.set(true);\n  wait(500, msec);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->driveDistance(6.5);\n  robotDrivetrain->turnToAngle(M_PI*.08);\n  intakeBeltMotor.spin(forward);\n  IntakeRollerMotor.spin(forward);\n  robotDrivetrain->driveDistance(37);\n  wait(1500, msec);\n  robotDrivetrain->turnParameters.maxVelocity = 50;\n  robotDrivetrain->turnToAngle(M_PI);\n}\n\nvoid soloHighRed(Drive* robotDrivetrain, motor &intakeBeltMotor, motor &armMotor, rotation &armRotationSensor, digital_out &doinkerPneumatic, digital_out &descorerPneumatic, motor &IntakeRollerMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  /* Demo functions:\n     Drive forward: robotDrivetrain->driveDistance({distance});\n     Turn to angle: robotDrivetrain->turnToAngle({angle});\n     Delay: wait({time}, msec);\n     */\n  /* [Removed auton]\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->turnParameters.maxVelocity = 60;\n  robotDrivetrain->driveDistance(-24);\n  robotDrivetrain->straightParameters.maxVelocity = 20;\n  robotDrivetrain->driveDistance(-7);\n  LeftMoGoPneumatic.set(true);\n  RightMoGoPneumatic.set(true);\n  IntakeRollerMotor.setVelocity(100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  IntakeRollerMotor.spin(forward);\n  robotDrivetrain->driveDistance(3);\n  wait(1000, msec);\n  robotDrivetrain->turnToAngle(-M_PI*.64);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->driveDistance(33);\n  robotDrivetrain->straightParameters.maxVelocity = 17.5;\n  robotDrivetrain->driveDistance(3);\n  robotDrivetrain->driveDistance(-10);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->turnToAngle(M_PI*.45);\n  robotDrivetrain->driveDistance(20);\n  robotDrivetrain->straightParameters.maxVelocity = 20;\n  robotDrivetrain->driveDistance(39);\n  */\n  /* [Removed auton]\n\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->turnParameters.maxVelocity = 80;\n  robotDrivetrain->driveDistance(-24);\n  robotDrivetrain->straightParameters.maxVelocity = 20;\n  robotDrivetrain->driveDistance(-7);\n  LeftMoGoPneumatic.set(true);\n  RightMoGoPneumatic.set(true);\n  IntakeRollerMotor.setVelocity(100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  IntakeRollerMotor.spin(forward);\n  wait(750, msec);\n  robotDrivetrain->turnToAngle(M_PI*.76);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->driveDistance(27);\n  wait(800, msec);\n  robotDrivetrain->straightParameters.maxVelocity = 17.5;\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->driveDistance(-21);\n  robotDrivetrain->turnToAngle(M_PI/2);\n  robotDrivetrain->driveDistance(26);\n  wait(200, msec);\n  robotDrivetrain->straightParameters.maxVelocity = 20;\n  robotDrivetrain->driveDistance(-6);\n  robotDrivetrain->turnToAngle(M_PI*.855);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->driveDistance(19.5);\n  wait(600, msec);\n  robotDrivetrain->driveDistance(-18);\n  robotDrivetrain->turnToAngle(-M_PI/2);\n  robotDrivetrain->driveDistance(55);\n  */\n  \n  robotDrivetrain->straightParameters.maxVelocity = 40;\n  robotDrivetrain->turnParameters.maxVelocity = 40;\n  robotDrivetrain->driveDistance(-17.75);\n  robotDrivetrain->turnToAngle(M_PI/2);\n  robotDrivetrain->driveDistance(-2.25);\n  LeftMoGoPneumatic.set(true);\n  RightMoGoPneumatic.set(true);\n  IntakeRollerMotor.setVelocity(100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  IntakeRollerMotor.spin(forward);\n  wait(550, msec);\n  intakeBeltMotor.stop();\n  IntakeRollerMotor.stop();\n  LeftMoGoPneumatic.set(false);\n  RightMoGoPneumatic.set(false);\n  robotDrivetrain->driveDistance(3);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->turnParameters.maxVelocity = 40;\n  robotDrivetrain->turnToAngle(-M_PI*.69);\n  robotDrivetrain->turnParameters.maxVelocity = 10;\n  robotDrivetrain->turnToAngle(-M_PI*.69);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->driveDistance(-34);\n  robotDrivetrain->straightParameters.maxVelocity = 35;\n  robotDrivetrain->turnParameters.maxVelocity = 50;\n  robotDrivetrain->driveDistance(-12);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  LeftMoGoPneumatic.set(true);\n  RightMoGoPneumatic.set(true);\n  wait(100, msec);\n  robotDrivetrain->turnToAngle(M_PI*.285);\n  IntakeRollerMotor.setVelocity(100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  IntakeRollerMotor.spin(forward);\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->driveDistance(27);\n  wait(400, msec);\n  robotDrivetrain->straightParameters.maxVelocity = 30;\n  robotDrivetrain->driveDistance(-22);\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->turnToAngle(0);\n  robotDrivetrain->driveDistance(28);\n  wait(500, msec);\n  robotDrivetrain->turnToAngle(M_PI);\n  robotDrivetrain->turnParameters.maxVelocity = 5;\n  robotDrivetrain->turnToAngle(M_PI);\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->driveDistance(60);\n  /* [bad auton]\n  \n  robotDrivetrain->straightParameters.maxVelocity = 40;\n  robotDrivetrain->turnParameters.maxVelocity = 40;\n  robotDrivetrain->driveDistance(-17.5);\n  robotDrivetrain->turnToAngle(M_PI/2);\n  robotDrivetrain->driveDistance(-2);\n  LeftMoGoPneumatic.set(true);\n  RightMoGoPneumatic.set(true);\n  IntakeRollerMotor.setVelocity(100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  IntakeRollerMotor.spin(forward);\n  wait(650, msec);\n  intakeBeltMotor.stop();\n  IntakeRollerMotor.stop();\n  LeftMoGoPneumatic.set(false);\n  RightMoGoPneumatic.set(false);\n  robotDrivetrain->driveDistance(3.3);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->turnParameters.maxVelocity = 80;\n  robotDrivetrain->turnToAngle(-M_PI*.665);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->driveDistance(-40);\n  robotDrivetrain->straightParameters.maxVelocity = 35;\n  robotDrivetrain->driveDistance(-9);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  LeftMoGoPneumatic.set(true);\n  RightMoGoPneumatic.set(true);\n  wait(100, msec);\n  robotDrivetrain->turnToAngle(M_PI*.26);\n  IntakeRollerMotor.setVelocity(100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  IntakeRollerMotor.spin(forward);\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->driveDistance(28);\n  wait(200, msec);\n  robotDrivetrain->straightParameters.maxVelocity = 17.5;\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->driveDistance(-26);\n  robotDrivetrain->turnToAngle(0);\n  robotDrivetrain->driveDistance(28);\n  robotDrivetrain->straightParameters.maxVelocity = 30;\n  robotDrivetrain->driveDistance(-7);\n  robotDrivetrain->turnToAngle(M_PI*.37);\n  robotDrivetrain->straightParameters.maxVelocity = 75;\n  robotDrivetrain->driveDistance(19);\n  wait(400, msec);\n  robotDrivetrain->driveDistance(-26);\n  robotDrivetrain->turnToAngle(M_PI);\n  robotDrivetrain->driveDistance(54);\n  */\n}\n\nvoid oldRed4RingSkills(Drive* robotDrivetrain, motor &intakeBeltMotor, motor &armMotor, rotation &armRotationSensor, digital_out &doinkerPneumatic, digital_out &descorerPneumatic, motor &intakeRollerMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->turnParameters.maxVelocity = 80;\n  robotDrivetrain->driveDistance(-24);\n  robotDrivetrain->straightParameters.maxVelocity = 20;\n  robotDrivetrain->driveDistance(-7);\n  leftMoGoPneumatic.set(true);\n  rightMoGoPneumatic.set(true);\n  intakeRollerMotor.setVelocity(100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  intakeRollerMotor.spin(forward);\n  leftMoGoPneumatic.set(true);\n  rightMoGoPneumatic.set(true);\n  intakeRollerMotor.setVelocity(-100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  intakeRollerMotor.spin(forward);\n  wait(750, msec);\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->turnParameters.maxVelocity = 20;\n  robotDrivetrain->turnToAngle(M_PI*.772);\n  intakeRollerMotor.setVelocity(-100,percent);\n  intakeBeltMotor.setVelocity(100,percent);\n  intakeBeltMotor.spin(forward);\n  intakeRollerMotor.spin(forward);\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->driveDistance(29.75);\n  wait(600, msec);\n  robotDrivetrain->straightParameters.maxVelocity = 50;\n  robotDrivetrain->driveDistance(-22.25);\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->turnToAngle(M_PI/2);\n  robotDrivetrain->driveDistance(28);\n  robotDrivetrain->turnParameters.maxVelocity = 30;\n  robotDrivetrain->turnToAngle(M_PI*.98);\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->driveDistance(15.5);\n   wait(600, msec);\n  robotDrivetrain->driveDistance(-16);\n  robotDrivetrain->turnParameters.maxVelocity = 30;\n  robotDrivetrain->turnToAngle(3*M_PI/2);\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  robotDrivetrain->driveDistance(65);\n  robotDrivetrain->driveDistance(-100);\n  leftMoGoPneumatic.set(false);\n  rightMoGoPneumatic.set(false);\n\n  \n}\n\nvoid bigSkills(Drive* robotDrivetrain, motor &intakeBeltMotor, motor &armMotor, rotation &armRotationSensor, digital_out &doinkerPneumatic, digital_out &descorerPneumatic, motor &intakeRollerMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  robotDrivetrain->odom->resetOrientation(); // Start using this in autons to set the starting angle, this will just make the starting angle 0\n  intakeBeltMotor.setVelocity(100, percent);\n  intakeRollerMotor.setVelocity(100, percent);\n\n  intakeBeltMotor.spin(forward);\n  wait(750, msec);\n  intakeBeltMotor.stop();\n\n  robotDrivetrain->driveDistance(14);\n  robotDrivetrain->turnToAngle(-M_PI/4);\n  intakeRollerMotor.spin(reverse);\n  robotDrivetrain->driveDistance(50);\n  wait(300, msec);\n  robotDrivetrain->turnParameters.maxVelocity = 30;\n  robotDrivetrain->turnToAngle(0.004*M_PI);\n  robotDrivetrain->turnParameters.maxVelocity = 50;\n  wait(300, msec);\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"Orientation: %f\", robotDrivetrain->odom->getOrientation());\n  robotDrivetrain->driveDistance(-15);\n  robotDrivetrain->straightParameters.maxVelocity = 20;\n  robotDrivetrain->driveDistance(-7);\n  robotDrivetrain->straightParameters.maxVelocity = 80;\n  leftMoGoPneumatic.set(true);\n  rightMoGoPneumatic.set(true);\n  intakeBeltMotor.spin(forward);\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"Orientation: %f\", robotDrivetrain->odom->getOrientation());\n  \n}\n\nvoid straightDebug(Drive* robotDrivetrain, motor &intakeBeltMotor, motor &armMotor, rotation &armRotationSensor, digital_out &doinkerPneumatic, digital_out &descorerPneumatic, motor &intakeRollerMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  robotDrivetrain->odom->resetOrientation(); // Start using this in autons to set the starting angle, this will just make the starting angle 0\n\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n  Brain.Screen.print(\"Orientation: %f\", robotDrivetrain->odom->getOrientation());\n  robotDrivetrain->driveDistance(30);\n  Brain.Screen.setCursor(3, 1);\n  Brain.Screen.print(\"Orientation: %f\", robotDrivetrain->odom->getOrientation());\n\n  wait(500, msec);\n  robotDrivetrain->leftDrive->stop(coast);\n  robotDrivetrain->rightDrive->stop(coast);\n}\n\n/* --------------- Start driver control ---------------*/\n\nvoid driverControl(Drive* robotDrivetrain, motor &intakeBeltMotor, motor &armMotor, rotation &armRotationSensor, digital_out &doinkerPneumatic, digital_out &descorerPneumatic, motor &intakeRollerMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  robotDrivetrain->leftDrive->stop(coast);\n  robotDrivetrain->rightDrive->stop(coast);\n  while (true) {\n    robotDrivetrain->driverControl();\n\n    // Intake\n    bool r1 = robotDrivetrain->remoteControl->ButtonR1.pressing();\n    bool r2 = robotDrivetrain->remoteControl->ButtonR2.pressing();\n    \n    int intakeSpinDirection = r2 - r1;\n\n    intakeBeltMotor.setVelocity(100 * (float) intakeSpinDirection, percent);\n    intakeBeltMotor.spin(forward);\n\n    intakeRollerMotor.setVelocity(100 * (float) intakeSpinDirection, percent);\n    intakeRollerMotor.spin(reverse);\n\n    \n    bool x = robotDrivetrain->remoteControl->ButtonX.pressing();\n    bool b = robotDrivetrain->remoteControl->ButtonB.pressing();\n    \n    \n    int intakeState = x - b;\n\n    if (intakeState == 1) {\n      doinkerPneumatic.set(true);\n    } else if (intakeState == -1) {\n      doinkerPneumatic.set(false);\n    }\n\n    // Arm\n    bool bDown = robotDrivetrain->remoteControl->ButtonDown.pressing();\n    bool bUp = robotDrivetrain->remoteControl->ButtonUp.pressing();\n    \n    int armSpinDirection = bUp - bDown;\n\n    armMotor.setVelocity(100 * (float) armSpinDirection, percent);\n    armMotor.spin(forward);\n\n    // MoGo Mech\n    bool l1 = robotDrivetrain->remoteControl->ButtonL1.pressing();\n    bool l2 = robotDrivetrain->remoteControl->ButtonL2.pressing();\n    \n    int mogoState = l2 - l1;\n\n    if (mogoState == 1) {\n      leftMoGoPneumatic.set(true);\n      rightMoGoPneumatic.set(true);\n    } else if (mogoState == -1) {\n      leftMoGoPneumatic.set(false);\n      rightMoGoPneumatic.set(false);\n    }\n\n    wait(DT, msec);\n  }\n}\n\n/* --------------- Start auton selector --------------- */\n\ntypedef void (*AutonFunction)(Drive*, motor&, motor&, rotation&, digital_out&, digital_out&, motor&, digital_out&, digital_out&);\n\ntypedef struct {\n  const char* name;\n  AutonFunction func;\n} AutonSelectorOption;\n\narray<AutonSelectorOption, 5> autonMap = {{\n  { \"Odometry Debugging\", &odomDebugAuton },\n  { \"Red Low Ally\", &redLowAlly },\n  { \"Blue Low Ally\", &blueLowAlly },\n  { \"Solo High Red\", &soloHighRed },\n  { \"Skills\", &bigSkills }\n}};\n\nAutonFunction SelectedAuton = autonMap[0].func;\n\nvoid autonSelector() {\n  int autonIndex = 0;\n  int numAutons = autonMap.size();\n  bool selected = false;\n  while (!selected) {\n    if (!Brain.Screen.pressing()) {\n      wait(DT, msec);\n      continue;\n    }\n\n    // Screen width is 480 pixels\n    int touchHorizontalCoordinate = Brain.Screen.xPosition();\n    if (touchHorizontalCoordinate > 480 / 2) {\n      autonIndex += 1;\n      if (autonIndex >= numAutons) {\n        autonIndex = 0;\n      }\n    } else {\n      autonIndex -= 1;\n      if (autonIndex < 0) {\n        autonIndex = numAutons - 1;\n      }\n    }\n\n    Brain.Screen.clearScreen();\n    Brain.Screen.print(autonMap[autonIndex].name);\n    SelectedAuton = autonMap[autonIndex].func;\n\n    wait(DT, msec);\n  }\n\n}\n\n/* --------------- Start main program --------------- */\n\nvoid preAutonomous(void) {\n  // actions to do when the program starts\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"pre auton code\");\n  InertialSensor.calibrate();\n  wait(3, seconds);\n  \n  autonSelector();\n}\n\nvoid templateAutonomous(void) { // Dummy wrapper function to call the desired autonomous (because the competition template can't take parameters)\n  Drive* robotDrivetrain = new Drive(LeftDrive, RightDrive, forward, forward, InertialSensor, RemoteControl);\n  robotDrivetrain->initOdom(InertialDriftEpsilon, DistLeft, DistRight, DistBack, LeftWheelRadius, RightWheelRadius, StraightParameters, TurnParameters, ArcParameters, HeadingParameters);\n\n  SelectedAuton(robotDrivetrain, IntakeBeltMotor, ArmMotor, ArmRotationSensor, DoinkerPneumatic, DescorerPneumatic, IntakeRollerMotor, LeftMoGoPneumatic, RightMoGoPneumatic);\n}\n\nvoid templateDriverControl(void) { // Dummy wrapper function to call the desired driver control (because the competition template can't take parameters)\n  Drive* robotDrivetrain = new Drive(LeftDrive, RightDrive, forward, forward, InertialSensor, RemoteControl);\n  robotDrivetrain->initOdom(InertialDriftEpsilon, DistLeft, DistRight, DistBack, LeftWheelRadius, RightWheelRadius, StraightParameters, TurnParameters, ArcParameters, HeadingParameters);\n\n  driverControl(robotDrivetrain, IntakeBeltMotor, ArmMotor, ArmRotationSensor, DoinkerPneumatic, DescorerPneumatic, IntakeRollerMotor, LeftMoGoPneumatic, RightMoGoPneumatic);\n}\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  // create competition instance\n  competition Competition;\n\n  // Set up callbacks for autonomous and driver control periods.\n  Competition.autonomous(templateAutonomous);\n  Competition.drivercontrol(templateDriverControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n  // Prevent main from exiting with an infinite loop.\n  while (true) {\n    wait(100, msec);\n  }\n}","textLanguage":"cpp","robotConfig":[],"slot":6,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}