{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\n\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       {author}                                                  */\n/*    Created:      {date}                                                    */\n/*    Description:  V5 project                                                */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Include the V5 Library\n#include \"vex.h\"\n\n// Included libraries (some redundent because of config block)\n#include <math.h>\n#include <array>\nusing std::array;\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n/* --------------- Start drive library --------------- */\n\n#pragma region Custom Drive Library\n\n#define INF std::numeric_limits<float>::infinity()\n#define DT 10\n\nusing transformMatrix = array<array<float, 2>, 2>;\n\nstruct coordinate {\n  float x;\n  float y;\n\n  coordinate(float x, float y) : x(x), y(y) {\n  }\n\n  coordinate& operator=(const coordinate& a) {\n    x = a.x;\n    y = a.y;\n    return *this;\n  }\n\n  coordinate operator+(const coordinate& a) {\n    return coordinate(a.x + x, a.y + y);\n  }\n\n  coordinate operator-(const coordinate& a) {\n    return coordinate(x - a.x, y - a.y);\n  }\n\n  bool operator==(const coordinate& a) {\n    return (x == a.x && y == a.y);\n  }\n\n  coordinate operator*(const transformMatrix& trans) {\n    return coordinate(x * trans[0][0] + y * trans[1][0], x * trans[0][1] + y * trans[1][1]);\n  }\n};\n\nclass Odometry {\n  private:\n    float resetOrientGlobal; // Global orientation at last reset\n    //float orientGlobalDrift;\n    float oldTimestamp;\n    float oldLeftAngle;\n    float oldRightAngle;\n    float oldOrientGlobal;\n    coordinate oldGlobalPosition = {0, 0}; // Previous global position vector\n    float timestamp;\n    float leftAngle;\n    float rightAngle;\n    float orientGlobal;\n    coordinate globalPosition = {0, 0};\n    float slippingEpsilon = 0.01;\n\n  public:\n    motor_group* leftDrive;\n    motor_group* rightDrive;\n    inertial* inertialSensor;\n    float orientGlobalDrift;\n    float inertialDriftEpsilon; // Minimum threshold used to determine whether or not turning is drift\n    float distLeft; // Distance from tracking center to left tracking wheel\n    float distRight; // Distance from tracking center to right tracking wheel\n    float distBack; // Distance from tracking center to back tracking wheel\n    float leftWheelRadius;\n    float rightWheelRadius;\n\n    Odometry(motor_group &_leftDrive, motor_group &_rightDrive, inertial &_inertialSensor, float _inertialDriftEpsilon, float _distLeft, float _distRight, float _distBack, float _leftWheelRadius, float _rightWheelRadius) {\n      leftDrive = &_leftDrive;\n      rightDrive = &_rightDrive;\n      inertialSensor = &_inertialSensor;\n      inertialDriftEpsilon = _inertialDriftEpsilon;\n      distLeft = _distLeft;\n      distRight = _distRight;\n      leftWheelRadius = _leftWheelRadius;\n      rightWheelRadius = _rightWheelRadius;\n    }\n\n    void initSensorValues() {\n      timestamp = Brain.Timer.time(seconds);\n      leftAngle = leftDrive->position(turns) * 2 * M_PI;\n      rightAngle = rightDrive->position(turns) * 2 * M_PI;\n      orientGlobal = inertialSensor->rotation(turns) * 2 * M_PI;\n      orientGlobalDrift = 0;\n      globalPosition = {0, 0};\n      oldTimestamp = timestamp;\n      oldLeftAngle = leftAngle;\n      oldRightAngle = rightAngle;\n      oldOrientGlobal = orientGlobal;\n      resetOrientGlobal = orientGlobal;\n      oldGlobalPosition = globalPosition;\n    }\n\n    void pollSensorValues() {\n      oldTimestamp = timestamp;\n      oldLeftAngle = leftAngle;\n      oldRightAngle = rightAngle;\n      oldOrientGlobal = orientGlobal;\n      timestamp = Brain.Timer.time(seconds);\n      leftAngle = leftDrive->position(turns) * 2 * M_PI;\n      rightAngle = rightDrive->position(turns) * 2 * M_PI;\n      orientGlobal = inertialSensor->rotation(turns) * 2 * M_PI;\n\n      if (fabs(orientGlobal - oldOrientGlobal) < inertialDriftEpsilon) {\n        orientGlobalDrift += orientGlobal - oldOrientGlobal;\n      }\n\n      // Calculate odometry\n      oldGlobalPosition = globalPosition;\n      globalPosition = globalPosition + getGlobalPositionChange();\n    }\n\n    // Getter methods\n\n    float getLeftAngle() {\n      return leftAngle;\n    }\n\n    float getLeftDistance() {\n      return leftAngle * leftWheelRadius;\n    }\n\n    float getRightAngle() {\n      return rightAngle;\n    }\n\n    float getRightDistance() {\n      return rightAngle * rightWheelRadius;\n    }\n\n    float getOrientation() {\n      return orientGlobal - resetOrientGlobal - orientGlobalDrift;\n    }\n\n    float getOldOrientation() {\n      return oldOrientGlobal;\n    }\n\n    coordinate getOldGlobalPosition() {\n      return oldGlobalPosition;\n    }\n\n    coordinate getGlobalPosition() {\n      return globalPosition;\n    }\n\n    float getDeltaTime() {\n      return timestamp - oldTimestamp;\n    }\n\n    float getDeltaLeftAngle() {\n      return leftAngle - oldLeftAngle;\n    }\n\n    float getDeltaLeftDistance() {\n      return getDeltaLeftAngle() * leftWheelRadius;\n    }\n\n    float getDeltaRightAngle() {\n      return rightAngle - oldRightAngle;\n    }\n\n    float getDeltaRightDistance() {\n      return getDeltaRightAngle() * rightWheelRadius;\n    }\n\n    float getDeltaOrientation() {\n      return orientGlobal - oldOrientGlobal;\n    }\n\n    coordinate getDeltaGlobalPosition() {\n      return globalPosition - oldGlobalPosition;\n    }\n\n    float getPredictedDeltaOrientation() {\n      float leftRightAngleDifference = getDeltaLeftAngle() - getDeltaRightAngle();\n      float drivetrainWidth = distLeft + distRight;\n      return leftRightAngleDifference / drivetrainWidth;\n    }\n\n    float getPathArcRadius() {\n      if (getDeltaOrientation() == 0) return INF;\n      if (getDeltaLeftAngle() == 0 && getDeltaRightAngle() == 0) return INF;\n      float leftRadius = getDeltaLeftDistance() / getDeltaOrientation() - distLeft;\n      float leftVelocity = leftRadius * getDeltaOrientation() / getDeltaTime();\n      float leftAcceleration = pow(leftVelocity, 2) / leftRadius;\n      float rightRadius = getDeltaRightDistance() / getDeltaOrientation() + distRight;\n      float rightVelocity = rightRadius * getDeltaOrientation() / getDeltaTime();\n      float rightAcceleration = pow(rightVelocity, 2) / rightRadius;\n      \n      float inertialAcceleration = inertialSensor->acceleration(yaxis);\n\n      float minSideRadiusAcceleration = leftAcceleration;\n      float minSideRadiusVelocity = leftVelocity;\n      float minSideRadius = leftRadius;\n      float minSideDeltaAngle = getDeltaLeftDistance();\n      float minSideDist = distLeft;\n\n      if (leftRadius > rightRadius) { // One side slipped more than the other\n        minSideRadiusAcceleration = rightAcceleration;\n        minSideRadiusVelocity = rightVelocity;\n        minSideRadius = rightRadius;\n        minSideDeltaAngle = getDeltaRightDistance();\n        minSideDist = distRight;\n      }\n      if (fabs(minSideRadiusAcceleration - inertialAcceleration) > slippingEpsilon) { // Slippage on both sides\n        minSideRadiusAcceleration = inertialAcceleration;\n        minSideRadiusVelocity = sqrt(minSideRadiusAcceleration * minSideRadius);\n        minSideRadius = minSideRadiusVelocity * getDeltaTime() / getDeltaOrientation();\n      }\n\n      return minSideRadius;\n    }\n\n    coordinate getGlobalPositionChange() {\n      coordinate localChange = {0, 2 * sinf(getDeltaOrientation() / 2) * getPathArcRadius()};\n\n      float localRotationOffset = getOldOrientation() + getDeltaOrientation() / 2;\n\n      // The extra pair of curly braces around the initializer in the line below is actually necessary (because c funkiness)\n      transformMatrix rotationMatrix = {{{cosf(-localRotationOffset), -sinf(-localRotationOffset)}, {sinf(-localRotationOffset), cosf(-localRotationOffset)}}};\n\n      coordinate globalChange = localChange * rotationMatrix;\n      if (getPathArcRadius() == INF) {\n        float deltaLeftDist = getDeltaLeftDistance();\n        float deltaRightDist = getDeltaRightDistance();\n        if ((deltaLeftDist < 0 && deltaRightDist > 0) || (deltaLeftDist > 0 && deltaRightDist < 0)) { // Forwards and Backwards (no movement)\n          globalChange = {0, 0};\n        } else if (deltaLeftDist == 0 || deltaRightDist == 0) { // No movement\n          globalChange = {0, 0};\n        } else if (deltaLeftDist > 0) { // Forwards\n          if (deltaLeftDist > deltaRightDist) {\n            globalChange = {0, deltaRightDist};\n          } else {\n            globalChange = {0, deltaLeftDist};\n          }\n        } else { // Backwards\n          if (deltaLeftDist > deltaRightDist) {\n            globalChange = {0, deltaLeftDist};\n          } else {\n            globalChange = {0, deltaRightDist};\n          }\n        }\n      }\n      return globalChange;\n    }\n};\n\nclass PID {\n  private:\n    float kp;\n    float ki;\n    float kd;\n    float integralRange;\n    float previousError;\n    float accumulatedError;\n    float timeRunning;\n    float timeout;\n    float settleThreshold;\n    float settleTime;\n    float timeSettled;\n\n  public:\n\n    PID(float startError, float _kp, float _ki, float _kd, float _integralRange) {\n      kp = _kp;\n      ki = _ki;\n      kd = _kd;\n      integralRange = _integralRange;\n      accumulatedError = 0;\n      previousError = startError;\n      timeRunning = 0;\n      timeSettled = 0;\n    }\n\n    bool isSettled() {\n      if ((timeRunning > timeout && timeout != 0) || timeSettled > settleTime) return true;\n      return false;\n    }\n\n    float calculateNextStep(float error) {\n      // Integral\n      accumulatedError = accumulatedError + error;\n      if (fabs(error) > integralRange) accumulatedError = 0; // Error outside of range for accumulating integral\n      if (error == 0 || (error > 0 &&  previousError < 0) || (error < 0 && previousError > 0)) accumulatedError = 0; // Error crossed 0\n\n      // Derivative\n      float deltaError = error - previousError;\n      previousError = error;\n\n      // Output\n      float outputPower = kp * error + ki * accumulatedError + kd * deltaError;\n      if (fabs(error) < settleThreshold) timeSettled += DT;\n      timeRunning += DT;\n      return outputPower;\n    }\n};\n\nstruct odomParameters {\n  float kp;\n  float ki;\n  float kd;\n  float integralRange;\n  float settleThreshold;\n  float settleTime;\n  float maxVelocity;\n\n  odomParameters(float kp, float ki, float kd, float integralRange, float settleThreshold, float settleTime, float maxVelocity) : kp(kp), ki(ki), kd(kd), integralRange(integralRange), settleThreshold(settleThreshold), settleTime(settleTime), maxVelocity(maxVelocity) {\n  }\n\n};\n\nclass Drive {\n  public:\n    motor_group* leftDrive;\n    motor_group* rightDrive;\n    directionType leftDirection = forward;\n    directionType rightDirection = reverse;\n    inertial* inertialSensor;\n    \n    controller* remoteControl;\n\n    Odometry* odom;\n    odomParameters straightParameters = {0, 0, 0, 0, 0, 0, 0};\n    odomParameters turnParameters = {0, 0, 0, 0, 0, 0, 0};\n    odomParameters headingParameters = {0, 0, 0, 0, 0, 0, 0};\n\n  Drive(motor_group &_leftDrive, motor_group &_rightDrive, inertial &_inertialSensor, controller &_remoteControl) {\n    leftDrive = &_leftDrive;\n    rightDrive = &_rightDrive;\n    inertialSensor = &_inertialSensor;\n    remoteControl = &_remoteControl;\n  }\n\n  Drive(motor_group &_leftDrive, motor_group &_rightDrive, directionType _leftDirection, directionType _rightDirection, inertial &_inertialSensor, controller &_remoteControl) {\n    leftDrive = &_leftDrive;\n    rightDrive = &_rightDrive;\n    leftDirection = _leftDirection;\n    rightDirection = _rightDirection;\n    inertialSensor = &_inertialSensor;\n    remoteControl = &_remoteControl;\n  }\n\n  void initOdom(float inertialDriftEpsilon, float distLeft, float distRight, float distBack, float leftWheelRadius, float rightWheelRadius, odomParameters _straightParameters, odomParameters _turnParameters, odomParameters _headingParameters) {\n    odom = new Odometry(*leftDrive, *rightDrive, *inertialSensor, inertialDriftEpsilon, distLeft, distRight, distBack, leftWheelRadius, rightWheelRadius);\n    odom->initSensorValues();\n    straightParameters = _straightParameters;\n    turnParameters = _turnParameters;\n    headingParameters = _headingParameters;\n  }\n\n  void driverControl() {\n    leftDrive->setVelocity(remoteControl->Axis3.position(), percent);\n    if (abs(remoteControl->Axis3.position()) > 3) {\n      leftDrive->spin(leftDirection);\n    }\n    rightDrive->setVelocity(remoteControl->Axis2.position(), percent);\n    if (abs(remoteControl->Axis2.position()) > 3) {\n      rightDrive->spin(rightDirection);\n    }\n  }\n\n  // General drive functions\n  void driveVelocity(float leftMotorPower, float rightMotorPower) {\n    leftDrive->setVelocity(leftMotorPower, percent);\n    leftDrive->spin(leftDirection);\n\n    rightDrive->setVelocity(rightMotorPower, percent);\n    rightDrive->spin(rightDirection);\n  }\n\n  void driveVelocity(float motorPower) {\n    driveVelocity(motorPower, motorPower);\n  }\n\n  float clampStraightVelocity(float motorVelocity) {\n    if (motorVelocity > straightParameters.maxVelocity) {\n      return straightParameters.maxVelocity;\n    } else if (motorVelocity < -straightParameters.maxVelocity) {\n      return -straightParameters.maxVelocity;\n    } else {\n      return motorVelocity;\n    }\n  }\n\n  float clampTurnVelocity(float motorVelocity) {\n    if (motorVelocity > turnParameters.maxVelocity) {\n      return turnParameters.maxVelocity;\n    } else if (motorVelocity < -turnParameters.maxVelocity) {\n      return -turnParameters.maxVelocity;\n    } else {\n      return motorVelocity;\n    }\n  }\n\n  float clampHeadingVelocity(float motorVelocity) {\n    if (motorVelocity > headingParameters.maxVelocity) {\n      return headingParameters.maxVelocity;\n    } else if (motorVelocity < -headingParameters.maxVelocity) {\n      return -headingParameters.maxVelocity;\n    } else {\n      return motorVelocity;\n    }\n  }\n\n  float reduceHeadingNegPiToPi(float headingAngle) { // Inspired by a pretty convenient utility function by Jackson Area Robotics\n    // Not using modulo because negative inputs are implementation dependent...\n    while (headingAngle > M_PI || headingAngle <= -M_PI) {\n      if (headingAngle > M_PI) {\n        headingAngle -= 2 * M_PI;\n      } else {\n        headingAngle += 2 * M_PI;\n      }\n    }\n    return headingAngle;\n  }\n\n  // Drivetrain autonomous functions\n  void odometryStep() {\n    odom->pollSensorValues();\n    wait(DT, msec);\n  }\n  \n  void driveDistance(float dist) {\n    float driveSetPoint = dist + (odom->getLeftDistance() + odom->getRightDistance()) / 2;\n    PID* drivePID = new PID(dist, straightParameters.kp, straightParameters.ki, straightParameters.kd, straightParameters.integralRange);\n    float headingSetPoint = odom->getOrientation();\n    PID* headingPID = new PID(0, headingParameters.kp, headingParameters.ki, headingParameters.kd, headingParameters.integralRange);\n    while (!drivePID->isSettled()) {\n      float distanceError = driveSetPoint - (odom->getLeftDistance() + odom->getRightDistance()) / 2;\n      float driveMotorVelocity = drivePID->calculateNextStep(distanceError);\n      \n      driveMotorVelocity = clampStraightVelocity(driveMotorVelocity);\n\n      float headingError = reduceHeadingNegPiToPi(headingSetPoint - odom->getOrientation());\n      float headingMotorVelocity = headingPID->calculateNextStep(headingError);\n\n      headingMotorVelocity = clampHeadingVelocity(headingMotorVelocity);\n      \n      driveVelocity(driveMotorVelocity + headingMotorVelocity, driveMotorVelocity - headingMotorVelocity);\n\n      odometryStep();\n    }\n  }\n\n  // Drivetrain autonomous functions\n  void turnToAngle(float targetAngle) {\n    float headingSetPoint = targetAngle;\n    PID* headingPID = new PID(headingSetPoint - odom->getOrientation(), headingParameters.kp, headingParameters.ki, headingParameters.kd, headingParameters.integralRange);\n    while (!headingPID->isSettled()) {\n      float headingError = reduceHeadingNegPiToPi(headingSetPoint - odom->getOrientation());\n      float headingMotorVelocity = headingPID->calculateNextStep(headingError);\n\n      headingMotorVelocity = clampHeadingVelocity(headingMotorVelocity);\n      \n      driveVelocity(headingMotorVelocity, -headingMotorVelocity);\n\n      odometryStep();\n    }\n  }\n\n};\n\n#pragma endregion Custom Drive Library\n\n/* --------------- Start robot configuration --------------- */\n\n// Drivetrain\nmotor LeftDriveMotorFront = motor(PORT1, ratio6_1, true);\nmotor LeftDriveMotorMiddle = motor(PORT2, ratio6_1, true);\nmotor LeftDriveMotorBack = motor(PORT3, ratio6_1, true);\nmotor_group LeftDrive = motor_group(LeftDriveMotorFront, LeftDriveMotorMiddle, LeftDriveMotorBack);\n\nmotor RightDriveMotorFront = motor(PORT4, ratio6_1, false);\nmotor RightDriveMotorMiddle = motor(PORT5, ratio6_1, false);\nmotor RightDriveMotorBack = motor(PORT6, ratio6_1, false);\nmotor_group RightDrive = motor_group(RightDriveMotorFront, RightDriveMotorMiddle, RightDriveMotorBack);\n\ninertial InertialSensor = inertial(PORT7);\n\n// Intake\nmotor IntakeMotor = motor(PORT10, ratio36_1, false);\ndigital_out IntakePneumatic = digital_out(Brain.ThreeWirePort.F);\n\n// Arm\nmotor ArmMotor = motor(PORT9, ratio36_1, false);\n\n// MoGo Mech\ndigital_out LeftMoGoPneumatic = digital_out(Brain.ThreeWirePort.G);\ndigital_out RightMoGoPneumatic = digital_out(Brain.ThreeWirePort.H);\n\ncontroller RemoteControl = controller(primary);\n\n// Odometry\nfloat InertialDriftEpsilon = 0.000025;\nfloat DistLeft = 7.5;\nfloat DistRight = 7.5;\nfloat DistBack = 0;\nfloat LeftWheelRadius = 1.625;\nfloat RightWheelRadius = 1.625;\nodomParameters StraightParameters = {0, 0, 0, 0, 0, 0, 0};\nodomParameters TurnParameters = {0, 0, 0, 0, 0, 0, 0};\nodomParameters HeadingParameters = {0, 0, 0, 0, 0, 0, 0};\n\n/* --------------- Start autons --------------- */\n\nvoid odomDebugAuton(Drive* robotDrivetrain, motor &intakeMotor, digital_out &intakePneumatic, motor &armMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  while (true) {\n    Brain.Screen.clearScreen();\n    Brain.Screen.setCursor(1, 1);\n    coordinate globalPosition = robotDrivetrain->odom->getGlobalPosition();\n    float xCoordinate = globalPosition.x;\n    float yCoordinate = globalPosition.y;\n    float leftRotation = robotDrivetrain->odom->getDeltaLeftAngle();\n    float rightRotation = robotDrivetrain->odom->getDeltaRightAngle();\n    float robotOrientation = robotDrivetrain->odom->getOrientation();\n    float arcRadius = robotDrivetrain->odom->getPathArcRadius();\n    Brain.Screen.print(\"X coordinate: %f\\n\", xCoordinate);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Y coordinate: %f\\n\", yCoordinate);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Left rotation: %f\\n\", leftRotation);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Right rotation: %f\\n\", rightRotation);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Orientation: %f\\n\", robotOrientation);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Arc Radius: %f\\n\", arcRadius);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"X: %f\\n\", globalPosition.x);\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Y: %f\\n\", globalPosition.y);\n\n\n\n    robotDrivetrain->odometryStep();\n  }\n}\n\nvoid babysFirstAuton(Drive* robotDrivetrain, motor &intakeMotor, digital_out &intakePneumatic, motor &armMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  /* Demo functions:\n     Drive forward: robotDrivetrain->driveDistance({distance});\n     Turn to angle: robotDrivetrain->turnToAngle({angle});\n     Delay: wait({time}, msec);\n     */\n}\n\n/* --------------- Start driver control ---------------*/\n\nvoid driverControl(Drive* robotDrivetrain, motor &intakeMotor, digital_out &intakePneumatic, motor &armMotor, digital_out &leftMoGoPneumatic, digital_out &rightMoGoPneumatic) {\n  while (true) {\n    robotDrivetrain->driverControl();\n\n    // Intake\n    bool r1 = robotDrivetrain->remoteControl->ButtonR1.pressing();\n    bool r2 = robotDrivetrain->remoteControl->ButtonR2.pressing();\n    \n    int intakeSpinDirection = r2 - r1;\n\n    intakeMotor.setVelocity(100 * (float) intakeSpinDirection, percent);\n    intakeMotor.spin(forward);\n\n    \n    bool bX = robotDrivetrain->remoteControl->ButtonX.pressing();\n    bool bB = robotDrivetrain->remoteControl->ButtonB.pressing();\n    \n    /*\n    int intakeState = bX - bB;\n\n    if (intakeState == 1) {\n      intakePneumatic.set(true);\n    } else if (intakeState == -1) {\n      intakePneumatic.set(false);\n    }*/\n\n    // Arm\n    bool bDown = robotDrivetrain->remoteControl->ButtonDown.pressing();\n    bool bUp = robotDrivetrain->remoteControl->ButtonUp.pressing();\n    \n    int armSpinDirection = bUp - bDown;\n\n    armMotor.setVelocity(100 * (float) armSpinDirection, percent);\n    armMotor.spin(forward);\n\n    // MoGo Mech\n    bool l1 = robotDrivetrain->remoteControl->ButtonL1.pressing();\n    bool l2 = robotDrivetrain->remoteControl->ButtonL2.pressing();\n    \n    int mogoState = l2 - l1;\n\n    if (mogoState == 1) {\n      leftMoGoPneumatic.set(true);\n      rightMoGoPneumatic.set(true);\n    } else if (mogoState == -1) {\n      leftMoGoPneumatic.set(false);\n      rightMoGoPneumatic.set(false);\n    }\n\n    wait(DT, msec);\n  }\n}\n\n/* --------------- Start main program --------------- */\n\n\n\nint main() {\n  Drive* robotDrivetrain = new Drive(LeftDrive, RightDrive, forward, forward, InertialSensor, RemoteControl);\n  robotDrivetrain->initOdom(InertialDriftEpsilon, DistLeft, DistRight, DistBack, LeftWheelRadius, RightWheelRadius, StraightParameters, TurnParameters, HeadingParameters);\n\n  babysFirstAuton(robotDrivetrain, IntakeMotor, IntakePneumatic, ArmMotor, LeftMoGoPneumatic, RightMoGoPneumatic);\n}","textLanguage":"cpp","robotConfig":[],"slot":3,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.5","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}